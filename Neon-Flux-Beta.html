<!DOCTYPE html>
<html lang="en"><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#000000">
<title>Neon Flux: Void Edition</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700;900&amp;display=swap" rel="stylesheet">
<style>
    :root {
        --bg-color: #000000;
        --glass-bg: rgba(10, 10, 25, 0.9);
        --glass-border: rgba(0, 240, 255, 0.3);
        --accent-primary: #00f0ff;
        --accent-secondary: #ff00aa;
        --accent-success: #00ff88;
        --accent-warn: #ffcc00;
        --accent-danger: #ff4444;
    }
    html, body {
        width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
        background: #000;
        color: white; font-family: 'Rajdhani', sans-serif;
        touch-action: none; -webkit-touch-callout: none;
        user-select: none; -webkit-user-select: none;
    }
    canvas { display: block; width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 10; }
    
    /* Background Layers */
    #bg-video {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        object-fit: cover; z-index: 0; opacity: 0; transition: opacity 0.5s;
        background: #000;
    }
    
    .glass-panel {
        background: var(--glass-bg);
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        border: 1px solid var(--glass-border);
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.9);
        border-radius: 16px;
    }
    
    /* Buttons */
    .btn-neon {
        background: rgba(0, 240, 255, 0.1);
        color: var(--accent-primary);
        border: 1px solid var(--accent-primary);
        font-family: 'Rajdhani', sans-serif;
        font-weight: 700;
        font-size: 1.1rem;
        padding: 14px 20px;
        text-transform: uppercase;
        letter-spacing: 2px;
        transition: all 0.2s ease;
        box-shadow: 0 0 15px rgba(0, 240, 255, 0.1);
        position: relative;
        overflow: hidden;
        width: 100%;
        border-radius: 6px;
    }
    .btn-neon:active {
        background: var(--accent-primary);
        color: #000;
        box-shadow: 0 0 30px var(--accent-primary);
        transform: scale(0.98);
    }
    .btn-neon:disabled {
        opacity: 0.5;
        pointer-events: none;
        filter: grayscale(100%);
    }
    
    .btn-secondary {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.15);
        color: #aaa;
        font-weight: 600;
        padding: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.2s;
        font-size: 0.8rem;
        width: 100%;
        border-radius: 6px;
    }
    .btn-secondary:active { background: rgba(255, 255, 255, 0.2); color: #fff; }

    .btn-icon {
        width: 44px; height: 44px;
        border-radius: 50%;
        background: rgba(0,0,0,0.6);
        border: 1px solid rgba(255,255,255,0.3);
        color: white;
        display: flex; align-items: center; justify-content: center;
        transition: all 0.2s;
        flex-shrink: 0;
    }
    .btn-icon:active { background: var(--accent-primary); color: black; border-color: var(--accent-primary); }

    /* Difficulty & Mods */
    .btn-diff {
        background: rgba(0,0,0,0.6);
        border: 1px solid #444;
        color: #888;
        font-weight: 700;
        font-size: 0.8rem;
        padding: 10px 4px;
        text-transform: uppercase;
        transition: all 0.2s;
        border-radius: 4px;
    }
    .btn-diff.active { transform: scale(1.05); color: #000; border-color: transparent; box-shadow: 0 0 15px currentColor; }
    .btn-diff[data-diff="NORMAL"].active { background: var(--accent-primary); color: #000; box-shadow: 0 0 15px var(--accent-primary); }
    .btn-diff[data-diff="HARD"].active { background: var(--accent-warn); color: #000; box-shadow: 0 0 15px var(--accent-warn); }
    .btn-diff[data-diff="MASTER"].active { background: var(--accent-secondary); color: #fff; box-shadow: 0 0 15px var(--accent-secondary); }
    .btn-diff[data-diff="CRAZY"].active { background: var(--accent-danger); color: #fff; box-shadow: 0 0 20px var(--accent-danger); animation: pulse-red 1s infinite; }

    .btn-mod {
        background: rgba(0,0,0,0.4);
        border: 1px solid #333;
        color: #666;
        font-weight: 700;
        font-size: 0.9rem;
        padding: 12px 4px;
        border-radius: 6px;
        transition: all 0.2s;
        position: relative;
        overflow: hidden;
    }
    .btn-mod.active {
        background: rgba(255, 255, 255, 0.1);
        border-color: var(--accent-primary);
        color: var(--accent-primary);
        text-shadow: 0 0 8px var(--accent-primary);
        box-shadow: inset 0 0 10px rgba(0,240,255,0.2);
    }
    .btn-mod.active::after {
        content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 2px; background: var(--accent-primary);
    }

    @keyframes pulse-red { 0% { box-shadow: 0 0 15px var(--accent-danger); } 50% { box-shadow: 0 0 25px var(--accent-danger); } 100% { box-shadow: 0 0 15px var(--accent-danger); } }

    .loader {
        width: 48px; height: 48px;
        border: 3px solid var(--accent-secondary);
        border-bottom-color: transparent;
        border-radius: 50%;
        display: inline-block;
        animation: rotation 1s linear infinite;
    }
    @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    .text-glow { text-shadow: 0 0 10px currentColor; }
    .hidden { display: none !important; }
    .flex-center { display: flex; flex-direction: column; align-items: center; justify-content: center; }
    
    .input-neon {
        background: rgba(0,0,0,0.5);
        border: 1px solid rgba(255,255,255,0.2);
        color: white;
        padding: 12px;
        border-radius: 6px;
        width: 100%;
        font-family: 'Rajdhani', sans-serif;
        font-size: 0.9rem;
        outline: none;
        transition: border-color 0.2s;
    }
    .input-neon:focus { border-color: var(--accent-primary); box-shadow: 0 0 10px rgba(0,240,255,0.2); }
    
    .bg-overlay {
        position: absolute; inset: 0; background: rgba(0,0,0,0.6); z-index: 5; pointer-events: none; transition: background 0.3s;
    }
    
    /* Health Bar */
    .health-container {
        width: 100%; height: 8px; background: #222; border-radius: 4px; overflow: hidden; margin-top: 6px; position: relative; border: 1px solid #444;
    }
    .health-fill {
        height: 100%; background: linear-gradient(90deg, #ff4444, #ffff00, #00ff88); width: 100%; transition: width 0.1s linear; box-shadow: 0 0 10px rgba(0,255,136,0.5);
    }
    .health-fill.danger {
        background: #ff4444; box-shadow: 0 0 15px #ff4444; animation: flash-danger 0.2s infinite;
    }
    @keyframes flash-danger { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

    /* Touch Feedback */
    .touch-lane {
        flex: 1;
        border-right: 1px solid rgba(255,255,255,0.05);
        transition: background 0.05s;
    }
    .touch-lane:last-child { border-right: none; }
    .touch-lane:active { background: linear-gradient(to top, rgba(255,255,255,0.1), transparent); }

    /* Custom Checkbox */
    .checkbox-wrapper {
        display: flex; align-items: center; justify-content: space-between; cursor: pointer; width: 100%;
        padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .checkbox-wrapper:last-child { border-bottom: none; }
    .checkbox-label { font-size: 0.9rem; font-weight: 600; color: #ddd; }
    
    .checkbox-input {
        appearance: none; width: 20px; height: 20px; border: 1px solid var(--accent-primary);
        background: rgba(0,0,0,0.5); border-radius: 4px; display: grid; place-content: center;
        transition: all 0.2s;
    }
    .checkbox-input::before {
        content: ""; width: 12px; height: 12px; transform: scale(0); transition: 0.1s transform ease-in-out;
        box-shadow: inset 1em 1em var(--accent-primary);
        transform-origin: center;
        clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
    }
    .checkbox-input:checked::before { transform: scale(1); background: var(--accent-primary); }
    .checkbox-input:checked { box-shadow: 0 0 10px rgba(0,240,255,0.3); }

    /* Mods Badge */
    .mod-badge {
        font-size: 0.65rem; padding: 2px 4px; border-radius: 2px; background: #333; color: #fff; margin-left: 2px;
    }
    .fullscreen {
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}

.fullscreen canvas {
    width: 60%; /* ปรับขนาดของลูกศรให้อยู่ตรงกลาง */
    height: 100%;
}

/* --- Mania (horizontal centered) mode --- */
.mania {
    display: flex;
    justify-content: center;
    align-items: stretch;
    overflow: hidden;
}
.mania canvas {
    width: 60vw;
    max-width: 1200px;
    height: 100vh;
    object-fit: contain;
}
</style>
<style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.pointer-events-none{pointer-events:none}.pointer-events-auto{pointer-events:none}.absolute{position:absolute}.inset-0{inset:0px}.bottom-0{bottom:0px}.left-0{left:0px}.z-40{z-index:40}.z-50{z-index:50}.z-\[60\]{z-index:60}.m-2{margin:0.5rem}.mb-0{margin-bottom:0px}.mb-1{margin-bottom:0.25rem}.mb-2{margin-bottom:0.5rem}.mb-4{margin-bottom:1rem}.mb-6{margin-bottom:1.5rem}.mb-8{margin-bottom:2rem}.mr-2{margin-right:0.5rem}.mt-1{margin-top:0.25rem}.mt-2{margin-top:0.5rem}.mt-auto{margin-top:auto}.flex{display:flex}.grid{display:grid}.hidden{display:none}.h-1{height:0.25rem}.h-\[35\%\]{height:35%}.h-full{height:100%}.h-px{height:1px}.w-0{width:0px}.w-64{width:16rem}.w-auto{width:auto}.w-full{width:100%}.max-w-xs{max-width:20rem}.flex-1{flex:1 1 0%}.cursor-pointer{cursor:pointer}.touch-none{touch-action:none}.grid-cols-2{grid-template-columns:repeat(2, minmax(0, 1fr))}.grid-cols-3{grid-template-columns:repeat(3, minmax(0, 1fr))}.grid-cols-4{grid-template-columns:repeat(4, minmax(0, 1fr))}.flex-col{flex-direction:column}.items-start{align-items:flex-start}.items-end{align-items:flex-end}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-1{gap:0.25rem}.gap-2{gap:0.5rem}.gap-3{gap:0.75rem}.gap-4{gap:1rem}.overflow-hidden{overflow:hidden}.overflow-y-auto{overflow-y:auto}.rounded{border-radius:0.25rem}.border{border-width:1px}.border-cyan-800{--tw-border-opacity:1;border-color:rgb(21 94 117 / var(--tw-border-opacity, 1))}.border-gray-700{--tw-border-opacity:1;border-color:rgb(55 65 81 / var(--tw-border-opacity, 1))}.border-red-900\/30{border-color:rgb(127 29 29 / 0.3)}.border-white\/10{border-color:rgb(255 255 255 / 0.1)}.border-yellow-500{--tw-border-opacity:1;border-color:rgb(234 179 8 / var(--tw-border-opacity, 1))}.border-yellow-900\/50{border-color:rgb(113 63 18 / 0.5)}.bg-black\/90{background-color:rgb(0 0 0 / 0.9)}.bg-black\/95{background-color:rgb(0 0 0 / 0.95)}.bg-gray-800{--tw-bg-opacity:1;background-color:rgb(31 41 55 / var(--tw-bg-opacity, 1))}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1))}.bg-white\/10{background-color:rgb(255 255 255 / 0.1)}.bg-white\/5{background-color:rgb(255 255 255 / 0.05)}.bg-gradient-to-b{background-image:linear-gradient(to bottom, var(--tw-gradient-stops))}.from-black\/90{--tw-gradient-from:rgb(0 0 0 / 0.9) var(--tw-gradient-from-position);--tw-gradient-to:rgb(0 0 0 / 0) var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-from), var(--tw-gradient-to)}.to-transparent{--tw-gradient-to:transparent var(--tw-gradient-to-position)}.p-2{padding:0.5rem}.p-4{padding:1rem}.p-6{padding:1.5rem}.px-4{padding-left:1rem;padding-right:1rem}.py-3{padding-top:0.75rem;padding-bottom:0.75rem}.py-6{padding-top:1.5rem;padding-bottom:1.5rem}.pt-4{padding-top:1rem}.text-center{text-align:center}.text-2xl{font-size:1.5rem;line-height:2rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-5xl{font-size:3rem;line-height:1}.text-\[10px\]{font-size:10px}.text-\[9px\]{font-size:9px}.text-sm{font-size:0.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:0.75rem;line-height:1rem}.font-black{font-weight:900}.font-bold{font-weight:700}.font-normal{font-weight:400}.uppercase{text-transform:uppercase}.italic{font-style:italic}.leading-none{line-height:1}.tracking-\[0\.4em\]{letter-spacing:0.4em}.tracking-tighter{letter-spacing:-0.05em}.tracking-wider{letter-spacing:0.05em}.tracking-widest{letter-spacing:0.1em}.text-cyan-300{--tw-text-opacity:1;color:rgb(103 232 249 / var(--tw-text-opacity, 1))}.text-cyan-400{--tw-text-opacity:1;color:rgb(34 211 238 / var(--tw-text-opacity, 1))}.text-gray-300{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity, 1))}.text-gray-400{--tw-text-opacity:1;color:rgb(156 163 175 / var(--tw-text-opacity, 1))}.text-gray-500{--tw-text-opacity:1;color:rgb(107 114 128 / var(--tw-text-opacity, 1))}.text-gray-600{--tw-text-opacity:1;color:rgb(75 85 99 / var(--tw-text-opacity, 1))}.text-green-400{--tw-text-opacity:1;color:rgb(74 222 128 / var(--tw-text-opacity, 1))}.text-red-400{--tw-text-opacity:1;color:rgb(248 113 113 / var(--tw-text-opacity, 1))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.text-yellow-100{--tw-text-opacity:1;color:rgb(254 249 195 / var(--tw-text-opacity, 1))}.text-yellow-400{--tw-text-opacity:1;color:rgb(250 204 21 / var(--tw-text-opacity, 1))}.opacity-70{opacity:0.7}.shadow-\[0_0_15px_rgba\(255\2c 200\2c 0\2c 0\.2\)\]{--tw-shadow:0 0 15px rgba(255,200,0,0.2);--tw-shadow-colored:0 0 15px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.backdrop-blur-sm{--tw-backdrop-blur:blur(4px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.duration-200{transition-duration:200ms}.hover\:border-white:hover{--tw-border-opacity:1;border-color:rgb(255 255 255 / var(--tw-border-opacity, 1))}.hover\:text-white:hover{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}</style></head>
<body>

<!-- Background Layers -->
<video id="bg-video" playsinline="" webkit-playsinline="" crossorigin="anonymous" loop="" muted=""></video>
<div id="bg-overlay-layer" class="bg-overlay"></div>

<!-- PeerJS CDN (needed for multiplayer P2P) -->
<script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

<!-- Canvas Layer -->
<canvas id="gameCanvas" width="509" height="895"></canvas>

<!-- UI Layer -->
<div id="ui-layer"
     class="absolute inset-0 z-50 pointer-events-auto flex flex-col justify-between safe-area-inset">
    
    <!-- HUD -->
    <div id="hud" class="hidden w-full flex flex-col p-4 pt-4 pointer-events-auto bg-gradient-to-b from-black/90 to-transparent">
        <div class="flex justify-between items-start w-full">
            <div class="flex flex-col">
                <div class="text-4xl font-bold text-glow leading-none" style="color:var(--accent-primary)">
                    <span id="score-display">0</span>
                </div>
                <div class="text-xs text-gray-400 tracking-widest font-bold">SCORE</div>
                <div id="active-mods-display" class="flex mt-1"></div>
            </div>
            
            <div id="remote-hud" class="flex flex-col items-end mr-4 text-xs text-gray-400" style="text-align:right;">
                <div class="text-[10px] text-gray-400">Remote</div>
                <div id="remote-id" class="text-xs text-gray-300">—</div>
                <div id="remote-stats" class="text-xs text-gray-400">Score: 0 • Combo: 0</div>
            </div>

            <div class="flex gap-3 items-center">
                <div class="flex flex-col items-end mr-2">
                    <div class="text-3xl font-bold text-glow leading-none" style="color:var(--accent-secondary)">
                        <span id="combo-display">0</span>
                    </div>
                    <div class="text-xs text-gray-400 tracking-widest font-bold">COMBO</div>
                </div>
                
                <button id="btn-pause" class="btn-icon">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
                </button>
            </div>
        </div>

        <!-- Health & Progress -->
        <div class="health-container">
            <div id="health-bar" class="health-fill"></div>
        </div>
        <div class="w-full h-1 bg-gray-800 mt-2 rounded overflow-hidden">
            <div id="progress-bar" class="h-full bg-white w-0 transition-all duration-200"></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 flex-center glass-panel pointer-events-auto z-50 m-2 overflow-y-auto no-scrollbar">
        <div class="w-full max-w-xs flex flex-col items-center py-6 px-4">
            <h1 class="text-5xl font-black mb-0 tracking-tighter text-center italic" style="color:var(--accent-primary); text-shadow: 0 0 20px var(--accent-primary);">NEON FLUX</h1>
            <p class="text-xs text-gray-300 mb-6 tracking-[0.4em] text-center font-bold">VOID EDITION</p>
            
            <!-- Difficulty -->
            <div class="w-full mb-4">
                <div class="grid grid-cols-4 gap-2 w-full">
                    <button class="btn-diff active" data-diff="NORMAL">Norm</button>
                    <button class="btn-diff" data-diff="HARD">Hard</button>
                    <button class="btn-diff" data-diff="MASTER">Mstr</button>
                    <button class="btn-diff" data-diff="CRAZY">CRZY</button>
                </div>
            </div>

            <!-- Mods & Settings Buttons -->
            <div class="w-full flex gap-2 mb-6">
                <button id="btn-open-mods" class="flex-1 btn-secondary text-xs flex flex-col items-center justify-center py-3">
                    <span class="mb-1">MODS</span>
                    <span id="mods-count" class="text-[9px] text-accent-primary">NONE</span>
                </button>
                <button id="btn-open-settings" class="flex-1 btn-secondary text-xs flex flex-col items-center justify-center py-3">
                    <span class="mb-1">SETTINGS</span>
                    <span class="text-[9px] text-gray-400">CONFIG</span>
                </button>
            </div>

            <!-- Import Section -->
            <div class="w-full mb-6 flex flex-col gap-3">
                <div class="flex flex-col gap-1">
                    <label class="text-[10px] text-gray-400 uppercase tracking-widest">Import Media URL</label>
                    <div class="flex gap-2">
                        <input type="text" id="url-input" class="input-neon" placeholder="Paste MP3 or MP4 URL..." autocomplete="off">
                        <button id="btn-load-url" class="btn-secondary w-auto px-4 text-cyan-300 border-cyan-800 font-bold">LOAD</button>
                    </div>
                    
                    <!-- Manual Override Toggle -->
                    <div class="flex items-center justify-between mt-2">
                        <div class="text-[9px] text-gray-500">
                            MP4: Video BG • MP3: Audio Only
                        </div>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="force-video" class="checkbox-input" style="width:16px;height:16px;">
                            <span class="text-[10px] text-accent-primary font-bold tracking-wider">FORCE VIDEO</span>
                        </label>
                    </div>
                </div>
            </div>
            <!-- IMPORT LOCAL FILE -->
            <div class="flex gap-2 mt-2">
                <input type="file" id="file-upload" accept="audio/*,video/*" class="hidden">
                <button id="btn-trigger-upload" class="btn-secondary w-full text-accent-primary border-accent-primary" style="background: rgba(0, 240, 255, 0.05);">
                            UPLOAD LOCAL FILE
                </button>
            </div>
                    
            <div class="h-px bg-white/10 w-full mb-6"></div>

            <!-- Request Song System -->
            <div class="w-full mb-6 flex flex-col gap-2">
                <label class="text-[10px] text-gray-400 uppercase tracking-widest text-accent-warn">Song Request System</label>
                
                <!-- The Request Input -->
                <input type="text" id="request-input" class="input-neon text-accent-primary font-bold" placeholder="Enter Song Name / Keyword..." autocomplete="off">
                
                <!-- The Template URL Input -->
                <input type="text" id="signal-url-input" class="input-neon border-yellow-900/50 text-yellow-100 text-[10px]" value="http://127.0.0.1:36525/latest?query=target" placeholder="Webhook URL (must contain 'target')" autocomplete="off">
                
                <!-- The Send Button -->
                <button id="btn-send-request" class="btn-neon text-sm py-3 mt-1 border-yellow-500 text-yellow-400 shadow-[0_0_15px_rgba(255,200,0,0.2)]">
                    SEND REQUEST
                </button>
                <div class="text-[9px] text-gray-500 text-center">Replaces "target" in URL with your input</div>
            </div>

            <!-- Copy Code Feature -->
            <!--
            <div class="w-full mb-6">
                <button id="btn-copy-code" class="btn-secondary text-[10px] py-3 border-gray-700 text-gray-500 hover:text-white hover:border-white transition-all">
                    COPY GAME SOURCE CODE
                </button>
            </div>
            -->
            
            <div class="w-full mb-4">
                <label class="text-[10px] text-gray-400 uppercase tracking-widest">Multiplayer (P2P)</label>
                <div class="flex gap-2 w-full mt-2">
                    <button id="peer-host-btn" class="btn-secondary w-1/2">Host (Create Peer)</button>
                    <button id="peer-copy-btn" class="btn-secondary w-1/2">Copy ID</button>
                </div>
                <div class="flex gap-2 w-full mt-2">
                    <input id="peer-id-display" class="input-neon" placeholder="Your peer id" readonly>
                    <input id="peer-connect-input" class="input-neon" placeholder="Enter peer id to connect">
                    <button id="peer-connect-btn" class="btn-neon w-auto px-4">Connect</button>
                </div>
                <div id="peer-status" class="text-[9px] text-gray-400 mt-2">Status: offline</div>
            </div>

            <div class="text-[9px] text-center text-gray-600 uppercase tracking-widest mt-auto">
                Mobile Portrait • Touch Only
            </div>
        </div>
    </div>

    <!-- Mods Selection Overlay -->
    <div id="mods-overlay" class="hidden absolute inset-0 flex-center bg-black/90 pointer-events-auto z-[60] backdrop-blur-sm">
        <div class="w-full max-w-xs p-6 glass-panel">
            <h2 class="text-2xl font-bold text-white mb-4 tracking-widest text-center">SELECT MODS</h2>
            <div class="grid grid-cols-2 gap-3 mb-6">
                <button class="btn-mod" data-mod="NF">NO FAIL<div class="text-[9px] mt-1 font-normal opacity-70">Cannot die</div></button>
                <button class="btn-mod" data-mod="EZ">EASY<div class="text-[9px] mt-1 font-normal opacity-70">Large hits, less dmg</div></button>
                <button class="btn-mod" data-mod="HR">HARD ROCK<div class="text-[9px] mt-1 font-normal opacity-70">Strict timing, high dmg</div></button>
                <button class="btn-mod" data-mod="HD">HIDDEN<div class="text-[9px] mt-1 font-normal opacity-70">Notes fade out</div></button>
                <button class="btn-mod" data-mod="DT">DOUBLE TIME<div class="text-[9px] mt-1 font-normal opacity-70">1.2x Speed</div></button>
                <button class="btn-mod" data-mod="HT">HALF TIME<div class="text-[9px] mt-1 font-normal opacity-70">0.85x Speed</div></button>
                <button class="btn-mod" data-mod="PF">PF - Perfectionist<div class="text-[9px] mt-1 font-normal opacity-70">Only PERFECT counts</div></button>
                <button class="btn-mod" data-mod="UNF">UNF - Unfixed Speed<div class="text-[9px] mt-1 font-normal opacity-70">Adaptive note speed</div></button>
            </div>
            <button id="btn-close-mods" class="btn-neon">CONFIRM</button>
        </div>
    </div>

    <!-- Settings Overlay -->
    <div id="settings-overlay" class="hidden absolute inset-0 flex-center bg-black/90 pointer-events-auto z-[60] backdrop-blur-sm">
        <div class="w-full max-w-xs p-6 glass-panel">
            <h2 class="text-2xl font-bold text-white mb-6 tracking-widest text-center">SETTINGS</h2>
            
            <div class="flex flex-col gap-2 mb-6 w-full">
                <label class="checkbox-wrapper">
                    <span class="checkbox-label">SFX (Sound Effects)</span>
                    <input type="checkbox" id="set-sfx" class="checkbox-input" checked="">
                </label>
                
                <label class="checkbox-wrapper">
                    <span class="checkbox-label">Visual FX (Particles)</span>
                    <input type="checkbox" id="set-fx" class="checkbox-input" checked="">
                </label>
                
                <label class="checkbox-wrapper">
                    <span class="checkbox-label">Arrow Background</span>
                    <input type="checkbox" id="set-lane-bg" class="checkbox-input" checked="">
                </label>
                
                <label class="checkbox-wrapper">
                    <span class="checkbox-label">Dark Background</span>
                    <input type="checkbox" id="set-bg-dim" class="checkbox-input" checked="">
                </label>

                <label class="checkbox-wrapper">
                    <span class="checkbox-label">Force Audio-only for Videos</span>
                    <input type="checkbox" id="set-force-audio" class="checkbox-input">
                </label>

                <!-- NEW: Horizontal Fullscreen (Mania) toggle -->
                <label class="checkbox-wrapper">
                    <span class="checkbox-label">Horizontal Fullscreen (Mania)</span>
                    <input type="checkbox" id="set-mania" class="checkbox-input">
                </label>

                <!-- NEW: Retry key binding -->
                <label class="checkbox-wrapper" style="align-items:center;">
                    <span class="checkbox-label">Retry Key</span>
                    <button id="btn-set-retry-key" class="btn-secondary" style="width:110px;">R</button>
                </label>

                <button class="btn-keybind" data-lane="0">L1 - D<div class="text-[9px] mt-1 font-normal opacity-70">Click to change</div></button>
<button class="btn-keybind" data-lane="1">L2 - F<div class="text-[9px] mt-1 font-normal opacity-70">Click to change</div></button>
<button class="btn-keybind" data-lane="2">L3 - J<div class="text-[9px] mt-1 font-normal opacity-70">Click to change</div></button>
<button class="btn-keybind" data-lane="3">L4 - K<div class="text-[9px] mt-1 font-normal opacity-70">Click to change</div></button>
            </div>
            <button id="btn-close-settings" class="btn-neon">CLOSE</button>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loading-screen" class="hidden absolute inset-0 flex-center glass-panel pointer-events-auto z-50 m-2">
        <span class="loader mb-6"></span>
        <h2 class="text-2xl font-bold text-white tracking-widest">PROCESSING</h2>
        <p id="loading-text" class="text-sm text-cyan-400 mt-2 text-center px-4">Analyzing frequency data...</p>
    </div>

    <!-- Pause Menu -->
    <div id="pause-menu" class="hidden absolute inset-0 flex-center glass-panel pointer-events-auto z-50 m-2 bg-black/95">
        <h2 class="text-4xl font-bold text-white mb-8 tracking-widest">PAUSED</h2>
        <div class="flex flex-col gap-4 w-64">
            <button id="btn-resume" class="btn-neon">RESUME</button>
            <button id="btn-restart-pause" class="btn-secondary">RESTART</button>
            <button id="btn-exit-pause" class="btn-secondary text-red-400 border-red-900/30">EXIT TO MENU</button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden absolute inset-0 flex-center glass-panel pointer-events-auto z-50 m-2">
        <h2 id="go-title" class="text-3xl font-bold text-white mb-2 tracking-tighter">TRACK COMPLETE</h2>
        <div class="text-5xl mb-6 font-bold text-glow" style="color:var(--accent-primary)">
            <span id="final-score">0</span>
        </div>
        
        <div class="grid grid-cols-3 gap-3 mb-8 w-full px-4">
            <div class="flex flex-col items-center p-2 bg-white/5 rounded border border-white/10">
                <div class="text-[9px] text-gray-400 tracking-widest mb-1">PERFECT</div>
                <div id="stat-perfect" class="text-xl font-bold text-green-400">0</div>
            </div>
            <div class="flex flex-col items-center p-2 bg-white/5 rounded border border-white/10">
                <div class="text-[9px] text-gray-400 tracking-widest mb-1">GOOD</div>
                <div id="stat-good" class="text-xl font-bold text-cyan-400">0</div>
            </div>
            <div class="flex flex-col items-center p-2 bg-white/5 rounded border border-white/10">
                <div class="text-[9px] text-gray-400 tracking-widest mb-1">MISS</div>
                <div id="stat-miss" class="text-xl font-bold text-red-400">0</div>
            </div>
        </div>

        <div class="flex items-center justify-center mb-4">
            <div class="text-[9px] text-gray-400 tracking-widest mr-2">MAX COMBO</div>
            <div id="stat-maxcombo" class="text-xl font-bold text-yellow-400">0</div>
        </div>

        <!-- NEW: Retry button -->
        <div class="flex gap-2 mb-4 w-full max-w-xs">
            <button id="btn-retry-gameover" class="btn-neon w-1/2">RETRY</button>
            <button id="btn-exit-gameover" class="btn-neon w-1/2">BACK TO MENU</button>
        </div>
    </div>

    <!-- Touch Controls Overlay -->
    <div id="touch-controls" class="absolute bottom-0 left-0 w-full h-[35%] flex pointer-events-auto z-40 touch-none">
        <div class="touch-lane" data-lane="0"></div>
        <div class="touch-lane" data-lane="1"></div>
        <div class="touch-lane" data-lane="2"></div>
        <div class="touch-lane" data-lane="3"></div>
    </div>
</div>

<script>
/**
 * NEON FLUX: VOID EDITION (REMASTERED)
 * ------------------------------
 * Features:
 * - URL Import only.
 * - Mods System (NF, EZ, HR, HD, DT, HT, PF).
 * - Settings Menu (SFX, FX, LaneBG, BG Dim).
 * - Request Song Webhook System (Manual Trigger).
 * - Procedural beatmap generation.
 * - Self-Replication (Copy Source).
 */

// --- CONFIGURATION ---
const DIFFICULTY_PRESETS = {
    NORMAL: { speed: 8,  sensitivity: 1.4, holdChance: 0.2, minSpeed: 6,  maxSpeed: 10 },
    HARD:   { speed: 11, sensitivity: 1.15, holdChance: 0.3, minSpeed: 9,  maxSpeed: 13 },
    MASTER: { speed: 14, sensitivity: 0.95, holdChance: 0.4, minSpeed: 12, maxSpeed: 18 },
    CRAZY:  { speed: 14.27, sensitivity: 0, holdChance: 2, minSpeed: 12, maxSpeed: 20 }
};

const CONFIG = {
    lanes: 4,
    inputOffset: 0, 
    basePoints: 100,
    holdTickPoints: 10,
    holdCompletePoints: 200,
    startHealth: 100,
    damageMiss: 15,
    healHit: 2
};

// --- GLOBALS ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: true });
const videoEl = document.getElementById('bg-video');
const bgOverlay = document.getElementById('bg-overlay-layer');

let animationFrameId;
let lastTime = 0;
// Adaptive speed cache (throttled calculation)
let lastSpeedCalc = 0;
let cachedAdaptiveSpeed = DIFFICULTY_PRESETS.NORMAL.speed;

// Game State
let gameState = 'MENU'; 
let isPaused = false;
let audioCtx = null;
let currentBuffer = null; 
let audioSource = null; 
let isVideoMode = false;
let startTime = 0;
let speedMultiplier = 1.0;

// Gameplay Stats
let score = 0;
let combo = 0;
let health = 100;
let stats = { perfect: 0, good: 0, miss: 0 };
let maxCombo = 0; // highest combo reached this session (updated on miss or end)
let currentDifficulty = 'NORMAL';

// Mods
let activeMods = {
    NF: false, // No Fail
    EZ: false, // Easy
    HR: false, // Hard Rock
    HD: false, // Hidden
    DT: false, // Double Time
    HT: false, // Half Time
    PF: false  // Perfectionist
    ,UNF: false // Unfixed Speed (adaptive note speed)
};

// Settings
let SETTINGS = {
    sfx: true,
    fx: true,
    laneBg: true, // "Arrow Background"
    bgDim: true,   // "Background Transparency" (Dark vs Light)
    mania: false,  // Horizontal centered fullscreen (osu!mania style)
    retryKey: 'KeyR', // default retry shortcut (can be changed by user)
    forceAudioForVideos: false // when true, treat video tracks as audio-only
};

// Chart Data
let notes = []; 
let trackDuration = 0;

// Input State
let laneHeld = [false, false, false, false];

// Visuals
const LANE_COLORS = ['#FF00FF', '#00FFFF', '#00FF00', '#FFAA00']; 
const LANE_GLOWS = ['rgba(255,0,255,0.6)', 'rgba(0,255,255,0.6)', 'rgba(0,255,0,0.6)', 'rgba(255,170,0,0.6)'];
let particles = [];
let popups = [];
let laneEffects = [0, 0, 0, 0]; 

// --- PeerJS P2P (simple) ---
let peer = null;
let conn = null;
let remoteInfo = { id: null, score: 0, combo: 0 };

function sendPeerMessage(obj) {
    if (conn && conn.open) {
        try { conn.send(obj); } catch (e) { console.warn('peer send err', e); }
    }
}

function setupConnection(c) {
    conn = c;
    const _ps = document.getElementById('peer-status');
    if (_ps) _ps.innerText = 'Connected: ' + c.peer;
    remoteInfo.id = c.peer;
    updateRemoteHUD();

    c.on('data', (data) => { handlePeerData(data); });
    c.on('open', () => {
        const _ps2 = document.getElementById('peer-status');
        if (_ps2) _ps2.innerText = 'Connected: ' + c.peer;
        try { c.send({ type: 'hello', id: (peer && peer.id) || null }); } catch (e) {}
    });
    c.on('close', () => { const _ps3 = document.getElementById('peer-status'); if (_ps3) _ps3.innerText = 'Disconnected'; remoteInfo.id = null; updateRemoteHUD(); });
    c.on('error', (e) => { console.warn('conn error', e); });
}

function handlePeerData(data) {
    if (!data || !data.type) return;
    if (data.type === 'hit') {
        remoteInfo.score = data.score || remoteInfo.score;
        remoteInfo.combo = data.combo || remoteInfo.combo;
        remoteInfo.id = data.id || remoteInfo.id;
        updateRemoteHUD();

        // Visual feedback for remote hit
        popups.push({ text: `R:${data.result}`, x: getLaneX(data.lane), y: (canvas.logicalHeight || (canvas.height / (window.devicePixelRatio || 1))) * 0.65, life: 0.9, color: '#FFD700', scale: 1.1 });
        createParticles(data.lane, 6, '#FFD700');
    } else if (data.type === 'hello') {
        remoteInfo.id = data.id || remoteInfo.id;
        updateRemoteHUD();
    }
}

function updateRemoteHUD() {
    const elId = document.getElementById('remote-id');
    const elStats = document.getElementById('remote-stats');
    if (elId) elId.innerText = remoteInfo.id || '—';
    if (elStats) elStats.innerText = `Score: ${remoteInfo.score} • Combo: ${remoteInfo.combo}`;
}

// --- AUDIO SYSTEM ---
const audioManager = {
    init: () => {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    },
    
    playSfx: (type) => {
        if (!audioCtx || !SETTINGS.sfx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        const now = audioCtx.currentTime;
        
        if (type === 'PERFECT') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(1200, now);
            osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.1);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        } else if (type === 'MISS') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.1);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        }
        osc.start(now);
        osc.stop(now + 0.1);
    }
};

// --- UI HANDLERS ---
function initUI() {
    // Difficulty
    document.querySelectorAll('.btn-diff').forEach(btn => {
        btn.addEventListener('click', (e) => {
            document.querySelectorAll('.btn-diff').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            currentDifficulty = e.target.getAttribute('data-diff');
        });
    });

    // Mods System
    const modOverlay = document.getElementById('mods-overlay');
    const btnOpenMods = document.getElementById('btn-open-mods');
    const btnCloseMods = document.getElementById('btn-close-mods');
    const modsCountSpan = document.getElementById('mods-count');
    const activeModsDisplay = document.getElementById('active-mods-display');

    btnOpenMods.addEventListener('click', () => {
        modOverlay.classList.remove('hidden');
    });

    btnCloseMods.addEventListener('click', () => {
        modOverlay.classList.add('hidden');
        updateModsDisplay();
    });

    document.querySelectorAll('.btn-mod').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const mod = btn.dataset.mod;
            activeMods[mod] = !activeMods[mod];
            
            // Mutual Exclusions
            if (mod === 'DT' && activeMods.DT) activeMods.HT = false;
            if (mod === 'HT' && activeMods.HT) activeMods.DT = false;
            if (mod === 'EZ' && activeMods.EZ) activeMods.HR = false;
            if (mod === 'EZ' && activeMods.EZ) activeMods.PF = false;
            if (mod === 'HR' && activeMods.HR) activeMods.EZ = false;
            if (mod === 'PF' && activeMods.PF) activeMods.EZ = false;
            
            // Refresh visuals
            document.querySelectorAll('.btn-mod').forEach(b => {
                const m = b.dataset.mod;
                if (activeMods[m]) b.classList.add('active');
                else b.classList.remove('active');
            });
        });
    });

    function updateModsDisplay() {
        const active = Object.keys(activeMods).filter(k => activeMods[k]);
        if (active.length === 0) {
            modsCountSpan.innerText = "NONE";
            modsCountSpan.className = "text-[9px] text-gray-500";
            activeModsDisplay.innerHTML = "";
        } else {
            modsCountSpan.innerText = active.join(", ");
            modsCountSpan.className = "text-[9px] text-accent-primary";
            activeModsDisplay.innerHTML = active.map(m => `<span class="mod-badge">${m}</span>`).join('');
        }
    }

    // Settings System
    const settingsOverlay = document.getElementById('settings-overlay');
    const btnOpenSettings = document.getElementById('btn-open-settings');
    const btnCloseSettings = document.getElementById('btn-close-settings');
    
    const chkSfx = document.getElementById('set-sfx');
    const chkFx = document.getElementById('set-fx');
    const chkLaneBg = document.getElementById('set-lane-bg');
    const chkBgDim = document.getElementById('set-bg-dim');
    const chkMania = document.getElementById('set-mania'); // NEW
    const chkForceAudio = document.getElementById('set-force-audio'); // NEW
    const btnSetRetryKey = document.getElementById('btn-set-retry-key');

    function displayKeyLabel(code) {
        if (!code) return '—';
        if (code === 'Enter' || code === 'NumpadEnter') return 'Enter';
        if (code.startsWith('Key')) return code.replace('Key','');
        if (code.startsWith('Digit')) return code.replace('Digit','');
        return code;
    }

    // reflect on open settings
    btnOpenSettings.addEventListener('click', () => {
        settingsOverlay.classList.remove('hidden');
        // reflect current setting
        chkMania.checked = SETTINGS.mania;
        chkForceAudio.checked = !!SETTINGS.forceAudioForVideos;
        btnSetRetryKey.innerText = displayKeyLabel(SETTINGS.retryKey);
    });

    // capture new retry key
    btnSetRetryKey.addEventListener('click', (ev) => {
        ev.preventDefault();
        btnSetRetryKey.innerText = 'Press any key...';
        btnSetRetryKey.classList.add('btn-neon');

        function onKey(e) {
            e.preventDefault();
            // ignore modifier-only keys
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight' || e.code === 'ControlLeft' || e.code === 'ControlRight' || e.code === 'AltLeft' || e.code === 'AltRight' || e.code === 'MetaLeft' || e.code === 'MetaRight') return;
            SETTINGS.retryKey = e.code;
            btnSetRetryKey.innerText = displayKeyLabel(SETTINGS.retryKey);
            btnSetRetryKey.classList.remove('btn-neon');
            document.removeEventListener('keydown', onKey, true);
        }

        // cancel capture if user clicks outside or presses Escape
        function cancelCapture(ev2) {
            if (ev2.type === 'keydown' && ev2.code === 'Escape') {
                btnSetRetryKey.innerText = displayKeyLabel(SETTINGS.retryKey);
                btnSetRetryKey.classList.remove('btn-neon');
                document.removeEventListener('keydown', onKey, true);
                document.removeEventListener('keydown', cancelCapture, true);
            }
        }

        document.addEventListener('keydown', onKey, true);
        document.addEventListener('keydown', cancelCapture, true);
    });

    // global handler: when Game Over screen visible, accept retry shortcut
    document.addEventListener('keydown', (e) => {
        if (e.repeat) return;
        const goScreen = document.getElementById('game-over-screen');
        const visible = goScreen && !goScreen.classList.contains('hidden');
        if (!visible) return;

        // Accept Enter / NumpadEnter always; otherwise compare to user-chosen retryKey
        if (e.code === 'Enter' || e.code === 'NumpadEnter' || e.code === SETTINGS.retryKey) {
            goScreen.classList.add('hidden');
            restartGame();
        }
    });

    btnCloseSettings.addEventListener('click', () => {
        settingsOverlay.classList.add('hidden');
    });

    chkSfx.addEventListener('change', (e) => SETTINGS.sfx = e.target.checked);
    chkFx.addEventListener('change', (e) => SETTINGS.fx = e.target.checked);
    chkLaneBg.addEventListener('change', (e) => SETTINGS.laneBg = e.target.checked);
    chkBgDim.addEventListener('change', (e) => {
        SETTINGS.bgDim = e.target.checked;
        if (isVideoMode) {
            bgOverlay.style.background = SETTINGS.bgDim ? 'rgba(0,0,0,0.7)' : 'rgba(0,0,0,0.3)';
        }
    });

    // Force audio-only for video tracks
    chkForceAudio.addEventListener('change', (e) => {
        SETTINGS.forceAudioForVideos = e.target.checked;
    });

    // NEW: mania toggle listener
    chkMania.addEventListener('change', (e) => {
        SETTINGS.mania = e.target.checked;
        // If currently fullscreen, adjust class immediately
        if (document.fullscreenElement) {
            if (SETTINGS.mania) document.body.classList.add('mania');
            else document.body.classList.remove('mania');
            // Force resize to update canvas internal size
            resizeCanvas();
        } else {
            // not fullscreen yet; still apply resize so preview works
            resizeCanvas();
        }
    });

    // keybinds
    let keybinds = {
    0: 'KeyD',
    1: 'KeyF',
    2: 'KeyJ',
    3: 'KeyK'
};

let keyHeld = new Array(CONFIG.lanes).fill(false);
    document.querySelectorAll('.btn-keybind').forEach(btn => {
    btn.addEventListener('click', () => {
        const lane = parseInt(btn.dataset.lane);

        btn.innerHTML = `L${lane+1} - ...<div class="text-[9px] mt-1 font-normal opacity-70">Press any key</div>`;

        function handler(e) {
            keybinds[lane] = e.code;

            updateKeybindButtons();
            document.removeEventListener('keydown', handler);
        }

        document.addEventListener('keydown', handler);
    });
});
function updateKeybindButtons() {
    document.querySelectorAll('.btn-keybind').forEach(btn => {
        const lane = parseInt(btn.dataset.lane);
        const keyName = keybinds[lane].replace('Key','');

        btn.innerHTML = `
        L${lane+1} - ${keyName}
        <div class="text-[9px] mt-1 font-normal opacity-70">
        Tap to change
        </div>`;
    });
}
document.addEventListener('keydown', (e) => {
    if (gameState !== 'PLAYING' || isPaused) return;
    if (e.repeat) return;

    for (let lane in keybinds) {
        if (e.code === keybinds[lane]) {
            const l = parseInt(lane);
            keyHeld[l] = true;
            laneHeld[l] = true;

            checkHit(l);
            laneEffects[l] = 1;
        }
    }
});

document.addEventListener('keyup', (e) => {
    for (let lane in keybinds) {
        if (e.code === keybinds[lane]) {
            const l = parseInt(lane);
            keyHeld[l] = false;
            laneHeld[l] = false;
        }
    }
});
    // Touch Inputs
    const touchZone = document.getElementById('touch-controls');

let activePointers = {}; 
// pointerId → lane

function getLaneFromX(x) {
    const rect = touchZone.getBoundingClientRect();
    const relativeX = x - rect.left;
    const laneWidth = rect.width / CONFIG.lanes;
    return Math.max(0, Math.min(CONFIG.lanes - 1, Math.floor(relativeX / laneWidth)));
}

touchZone.style.touchAction = "none";

touchZone.addEventListener('pointerdown', (e) => {
    e.preventDefault();

    const lane = getLaneFromX(e.clientX);

    activePointers[e.pointerId] = lane;
    laneHeld[lane] = true;

    if (gameState === 'PLAYING' && !isPaused) {
        checkHit(lane);
        laneEffects[lane] = 1;
    }
});

touchZone.addEventListener('pointermove', (e) => {
    if (!(e.pointerId in activePointers)) return;

    const oldLane = activePointers[e.pointerId];
    const newLane = getLaneFromX(e.clientX);

    if (oldLane !== newLane) {

        laneHeld[oldLane] = false;

        laneHeld[newLane] = true;

        if (gameState === 'PLAYING' && !isPaused) {
            checkHit(newLane);
            laneEffects[newLane] = 1;
        }

        activePointers[e.pointerId] = newLane;
    }
});

touchZone.addEventListener('pointerup', (e) => {
    if (!(e.pointerId in activePointers)) return;

    const lane = activePointers[e.pointerId];
    laneHeld[lane] = false;

    delete activePointers[e.pointerId];
});

touchZone.addEventListener('pointercancel', (e) => {
    if (!(e.pointerId in activePointers)) return;

    const lane = activePointers[e.pointerId];
    laneHeld[lane] = false;

    delete activePointers[e.pointerId];
});

    // Button Actions
    document.getElementById('btn-load-url').addEventListener('click', handleUrlLoad);
    document.getElementById('btn-pause').addEventListener('click', togglePause);
    document.getElementById('btn-resume').addEventListener('click', togglePause);
    document.getElementById('file-upload').addEventListener('change', handleFileUpload);
    document.getElementById('btn-restart-pause').addEventListener('click', restartGame);
    document.getElementById('btn-exit-pause').addEventListener('click', exitToMenu);
    // NEW: retry from game over / track complete
    document.getElementById('btn-retry-gameover').addEventListener('click', () => {
        // Hide game-over UI then restart current song/session
        document.getElementById('game-over-screen').classList.add('hidden');
        restartGame();
    });
    document.getElementById('btn-exit-gameover').addEventListener('click', exitToMenu);
    document.getElementById('btn-send-request').addEventListener('click', handleSendRequest);

    // --- Multiplayer (PeerJS) UI bindings ---
    const peerHostBtn = document.getElementById('peer-host-btn');
    const peerCopyBtn = document.getElementById('peer-copy-btn');
    const peerIdDisplay = document.getElementById('peer-id-display');
    const peerConnectInput = document.getElementById('peer-connect-input');
    const peerConnectBtn = document.getElementById('peer-connect-btn');
    const peerStatusEl = document.getElementById('peer-status');

    if (peerHostBtn) {
        peerHostBtn.addEventListener('click', () => {
            if (peer) { try { peer.destroy(); } catch (e) {} peer = null; conn = null; }
            peer = new Peer();
            peer.on('open', (id) => {
                if (peerIdDisplay) peerIdDisplay.value = id;
                if (peerStatusEl) peerStatusEl.innerText = 'Host ID: ' + id;
            });
            peer.on('connection', (c) => { setupConnection(c); });
            peer.on('error', (e) => { console.warn('Peer error', e); if (peerStatusEl) peerStatusEl.innerText = 'Error'; });
        });
    }

    if (peerCopyBtn) {
        peerCopyBtn.addEventListener('click', () => {
            const idVal = (peerIdDisplay && peerIdDisplay.value) || (peer && peer.id);
            if (idVal && navigator.clipboard) navigator.clipboard.writeText(idVal).catch(() => {});
        });
    }

    if (peerConnectBtn) {
        peerConnectBtn.addEventListener('click', () => {
            const target = (peerConnectInput && peerConnectInput.value || '').trim();
            if (!target) return alert('Enter peer id');
            if (!peer) {
                peer = new Peer();
                peer.on('open', () => { if (peerStatusEl) peerStatusEl.innerText = 'Ready'; });
                peer.on('connection', (c) => { setupConnection(c); });
                peer.on('error', (e) => { console.warn(e); if (peerStatusEl) peerStatusEl.innerText = 'Error'; });
            }
            const c = peer.connect(target);
            c.on('open', () => { setupConnection(c); });
            c.on('error', (e) => { console.warn('conn error', e); if (peerStatusEl) peerStatusEl.innerText = 'Conn Error'; });
        });
    }
}

// --- REQUEST SONG HANDLER ---
function handleSendRequest() {
    const template = document.getElementById('signal-url-input').value.trim();
    const query = document.getElementById('request-input').value.trim();
    const btn = document.getElementById('btn-send-request');

    if(!template || !query) {
        alert("Please enter both a Webhook URL and a Request Name.");
        return;
    }

    if(template.indexOf('target') === -1) {
        alert("Webhook URL must contain the word 'target' to be replaced.");
        return;
    }

    // Replace 'target' with encoded query
    const finalUrl = template.replace('target', encodeURIComponent(query));
    
    // Visual feedback
    const originalText = btn.innerText;
    btn.innerText = "SENDING...";
    btn.disabled = true;

    // Fire and forget fetch
    fetch(finalUrl, { method: 'GET', mode: 'no-cors' })
        .then(() => {
            btn.innerText = "SENT!";
            btn.style.borderColor = "#00ff88";
            btn.style.color = "#00ff88";
            setTimeout(() => {
                btn.innerText = originalText;
                btn.disabled = false;
                btn.style.borderColor = "";
                btn.style.color = "";
            }, 2000);
        })
        .catch(err => {
            console.error(err);
            btn.innerText = "ERROR";
            btn.style.borderColor = "#ff4444";
            btn.style.color = "#ff4444";
            setTimeout(() => {
                btn.innerText = originalText;
                btn.disabled = false;
                btn.style.borderColor = "";
                btn.style.color = "";
            }, 2000);
        });
}

// --- BEAT DETECTION ALGORITHM ---
async function analyzeAudio(buffer) {
    const channelData = buffer.getChannelData(0);
    const sampleRate = buffer.sampleRate;

    notes = [];
    const windowSize = 0.04; 
    const samplesPerWindow = Math.floor(sampleRate * windowSize);
    const settings = DIFFICULTY_PRESETS[currentDifficulty];

    const sensitivity = settings.sensitivity;

    const energyMap = [];

    // --- STEP 1: Calculate RMS Energy ---
    for (let i = 0; i < channelData.length; i += samplesPerWindow) {
        let sum = 0;
        for (let j = 0; j < samplesPerWindow && i + j < channelData.length; j++) {
            const s = channelData[i + j];
            sum += s * s;
        }

        const rms = Math.sqrt(sum / samplesPerWindow);

        energyMap.push({
            time: i / sampleRate,
            energy: rms
        });
    }

    const historySize = 20;
    const minDistance = currentDifficulty === 'CRAZY' ? 0.08 :
                        currentDifficulty === 'MASTER' ? 0.12 : 0.18;

    let lastNoteTime = -999;

    // --- STEP 2: Onset Detection using Energy + Delta ---
    for (let i = historySize; i < energyMap.length - 1; i++) {

        const current = energyMap[i];
        const prev = energyMap[i - 1];

        // local average
        let localAvg = 0;
        for (let j = 1; j <= historySize; j++) {
            localAvg += energyMap[i - j].energy;
        }
        localAvg /= historySize;

        const delta = current.energy - prev.energy;

        // 조건: energy สูง + เพิ่มขึ้นเร็ว
        if (
            current.energy > localAvg * sensitivity &&
            delta > 0.005 &&
            current.energy > 0.015
        ) {
            // peak check
            if (
                current.energy > energyMap[i - 1].energy &&
                current.energy > energyMap[i + 1].energy
            ) {
                if (current.time - lastNoteTime < minDistance) continue;

                lastNoteTime = current.time;

                // ---- LANE SELECTION BASED ON ENERGY ----
                // ไม่สุ่ม แต่กระจายตามพลังงาน
                const baseLane = Math.floor(
                    (current.energy * 1000) % CONFIG.lanes
                );

                const noteStrength = current.energy / localAvg;

                // ===== SINGLE NOTE =====
                notes.push(createNote(current.time, baseLane));

                // ===== DOUBLE NOTE (STRONG BEAT) =====
                if (noteStrength > 2.2 && CONFIG.lanes >= 4) {
                    const secondLane = (baseLane + 2) % CONFIG.lanes;
                    notes.push(createNote(current.time, secondLane));
                }

                // ===== TRIPLE (CRAZY MODE) =====
                if (
                    currentDifficulty === "CRAZY" &&
                    noteStrength > 3.0 &&
                    CONFIG.lanes >= 4
                ) {
                    const thirdLane = (baseLane + 1) % CONFIG.lanes;
                    notes.push(createNote(current.time, thirdLane));
                }
            }
        }
    }

    // --- STEP 3: Convert Some Notes to HOLD Based on Real Gaps ---
    for (let i = 0; i < notes.length - 1; i++) {
        const curr = notes[i];
        const next = notes[i + 1];

        const gap = next.time - curr.time;

        if (gap > 0.6 && gap < 2.5) {
            curr.type = 'HOLD';
            curr.duration = gap - 0.15;
        }
    }

    return notes;
}

// Helper
function createNote(time, lane) {
    return {
        time: time,
        lane: lane,
        type: 'TAP',
        duration: 0,
        hit: false,
        missed: false,
        holding: false,
        processed: false
    };
}

// --- CORE FUNCTIONS ---
function initGame() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    initUI();
    requestAnimationFrame(gameLoop);
}

function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;

    if (SETTINGS.mania || document.body.classList.contains('mania')) {
        const targetVisualWidth = Math.min(window.innerWidth * 0.60, 1200); // CSS pixels
        const visualHeight = window.innerHeight; // CSS pixels

        canvas.width = Math.floor(targetVisualWidth * dpr);
        canvas.height = Math.floor(visualHeight * dpr);

        // store logical (CSS) size for drawing calculations
        canvas.logicalWidth = Math.floor(canvas.width / dpr);
        canvas.logicalHeight = Math.floor(canvas.height / dpr);

        canvas.style.width = `${canvas.logicalWidth}px`;
        canvas.style.height = `${canvas.logicalHeight}px`;

        canvas.style.left = `${Math.floor((window.innerWidth - targetVisualWidth) / 2)}px`;
        canvas.style.top = `0px`;
    } else {
        const visualWidth = window.innerWidth;
        const visualHeight = window.innerHeight;

        const dprVal = dpr;
        canvas.width = Math.floor(visualWidth * dprVal);
        canvas.height = Math.floor(visualHeight * dprVal);

        canvas.logicalWidth = Math.floor(canvas.width / dprVal);
        canvas.logicalHeight = Math.floor(canvas.height / dprVal);

        canvas.style.width = `${canvas.logicalWidth}px`;
        canvas.style.height = `${canvas.logicalHeight}px`;
        canvas.style.left = `0px`;
        canvas.style.top = `0px`;
    }

    // scale context so drawing coordinates use CSS pixels
    ctx.setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);
}

function getLaneX(lane) {
    // use logical (CSS) width for lane math
    const laneWidth = (canvas.logicalWidth || canvas.width) / CONFIG.lanes;
    // no extra offset needed because canvas is visually centered via style.left
    const offsetX = 0;
    return offsetX + lane * laneWidth + laneWidth / 2;
}

function exitToMenu() {
    stopPlayback();
    gameState = 'MENU';
    isPaused = false;
    
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('pause-menu').classList.add('hidden');
    document.getElementById('hud').classList.add('hidden');
    document.getElementById('start-screen').classList.remove('hidden');
    document.getElementById('start-screen').classList.add('flex-center');
    
    videoEl.style.opacity = 0;
    videoEl.src = "";
    resetGameVars();
}

function stopPlayback() {
    if (audioSource) {
        try { audioSource.stop(); } catch(e){}
        audioSource = null;
    }
    if (videoEl) {
        videoEl.pause();
    }
}

function resetGameVars() {
    score = 0;
    combo = 0;
    health = CONFIG.startHealth;
    laneHeld = [false, false, false, false];
    maxCombo = 0;
}

function restartGame() {
    stopPlayback();
    // Ensure pause menu is closed when restarting from pause
    const pauseMenuEl = document.getElementById('pause-menu');
    if (pauseMenuEl) pauseMenuEl.classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    isPaused = false;
    resetGameVars();
    startGame();
}

function togglePause() {
    if (gameState !== 'PLAYING') return;
    isPaused = !isPaused;
    const pauseMenu = document.getElementById('pause-menu');
    
    if (isPaused) {
        if (isVideoMode) videoEl.pause();
        else if (audioCtx) audioCtx.suspend();
        pauseMenu.classList.remove('hidden');
    } else {
        pauseMenu.classList.add('hidden');
        if (isVideoMode) videoEl.play();
        else audioCtx.resume();
    }
}

// --- LOADING & IMPORTING ---
async function handleUrlLoad() {
    const url = document.getElementById('url-input').value.trim();
    if (!url) return;
    
    audioManager.init();
    
    // Improved Detection Logic
    const ext = url.split('.').pop().toLowerCase().split('?')[0];
    const videoExts = ['mp4', 'webm', 'ogg', 'mov', 'm4v', 'mkv'];
    
    // Check manual override first, then auto-detect
    const forceVideo = document.getElementById('force-video').checked;
    isVideoMode = forceVideo || videoExts.includes(ext);

    // If user prefers audio-only for videos, override detection
    if (SETTINGS.forceAudioForVideos) {
        isVideoMode = false;
    }
    
    setLoading(true, isVideoMode ? "Fetching Video..." : "Fetching Audio...");

    try {
        if (isVideoMode) {
            // Setup Video Element
            videoEl.src = url;
            videoEl.load();
        }

        // We fetch the file as a blob/buffer to analyze beats regardless of type
        const response = await fetch(url);
        if (!response.ok) throw new Error("Network error");
        const arrayBuffer = await response.arrayBuffer();
        
        await processAudio(arrayBuffer);
    } catch (e) {
        console.error(e);
        setLoading(false);
        alert("Load failed. Ensure the URL allows CORS (Access-Control-Allow-Origin).");
    }
}
const fileUpload = document.getElementById('file-upload');
const btnTriggerUpload = document.getElementById('btn-trigger-upload');
btnTriggerUpload.addEventListener('click', () => fileUpload.click());
async function handleFileUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    document.getElementById('url-input').value = "";
    audioManager.init();
    
    const isVideo = file.type.startsWith('video');
    const forceVideo = document.getElementById('force-video').checked;
    isVideoMode = forceVideo || isVideo;

    // Respect global setting: force audio-only for videos (applies to local files too)
    if (SETTINGS.forceAudioForVideos) {
        isVideoMode = false;
    }

    setLoading(true, isVideoMode ? "Processing Video File..." : "Processing Audio File...");

    try {
        if (isVideoMode) {
            const objectUrl = URL.createObjectURL(file);
            videoEl.src = objectUrl;
            videoEl.load();
        }
        const arrayBuffer = await file.arrayBuffer();
        await processAudio(arrayBuffer);
    } catch (err) {
        console.error(err);
        setLoading(false);
        alert("File load failed.");
    }
}


async function processAudio(arrayBuffer) {
    setLoading(true, "Decoding Data...");
    try {
        // Decode audio data for beat analysis
        const decodedBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        currentBuffer = decodedBuffer;
        trackDuration = decodedBuffer.duration;
        
        setLoading(true, `Generating ${currentDifficulty} Chart...`);
        
        // Wait a frame to let UI update
        setTimeout(async () => {
            await analyzeAudio(decodedBuffer);
            startGame();
        }, 50);
    } catch (e) {
        setLoading(false);
        alert("Decode failed. Format not supported.");
    }
}

function setLoading(active, text = "") {
    const el = document.getElementById('loading-screen');
    const txt = document.getElementById('loading-text');
    if (active) {
        el.classList.remove('hidden');
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('start-screen').classList.remove('flex-center');
        txt.innerText = text;
        gameState = 'ANALYZING';
    } else {
        el.classList.add('hidden');
    }
}

function startGame() {
    setLoading(false);
    gameState = 'PLAYING';
    resetGameVars();
    stats = { perfect: 0, good: 0, miss: 0 };
    particles = [];
    popups = [];
    
    // Calculate Speed Multiplier based on Mods
    speedMultiplier = 1.0;
    if (activeMods.DT) speedMultiplier = 1.2;
    if (activeMods.HT) speedMultiplier = 0.85;

    notes.forEach(n => {
        n.hit = false;
        n.missed = false;
        n.processed = false;
        n.holding = false;
    });
    
    document.getElementById('hud').classList.remove('hidden');
    updateHUD();
    
    // Setup Visuals based on Mode
    if (isVideoMode) {
        // VIDEO MODE
        videoEl.style.opacity = 0.6; 
        bgOverlay.style.background = SETTINGS.bgDim ? 'rgba(0,0,0,0.7)' : 'rgba(0,0,0,0.3)';
        
        videoEl.currentTime = 0;
        videoEl.muted = false; 
        videoEl.loop = false;
        videoEl.playbackRate = speedMultiplier;
        videoEl.play().catch(e => console.log("Video play error:", e));
        videoEl.onended = () => { if(gameState === 'PLAYING') endGame(true); };
    } else {
        // AUDIO MODE - VOID (Blank Black Background)
        videoEl.style.opacity = 0;
        bgOverlay.style.background = 'transparent';
        
        audioSource = audioCtx.createBufferSource();
        audioSource.buffer = currentBuffer;
        audioSource.playbackRate.value = speedMultiplier;
        audioSource.connect(audioCtx.destination);
        audioSource.start(0);
        startTime = audioCtx.currentTime;
        audioSource.onended = () => { if(gameState === 'PLAYING') endGame(true); };
    }
}

function endGame(win = false) {
    gameState = 'GAMEOVER';
    // ensure we capture highest combo at end of session
    maxCombo = Math.max(maxCombo, combo);
    stopPlayback();
    
    document.getElementById('hud').classList.add('hidden');
    document.getElementById('game-over-screen').classList.remove('hidden');
    
    document.getElementById('go-title').innerText = win ? "TRACK COMPLETE" : "GAME OVER";
    document.getElementById('go-title').style.color = win ? "#fff" : "#ff4444";
    
    document.getElementById('final-score').innerText = score.toLocaleString();
    document.getElementById('stat-perfect').innerText = stats.perfect;
    document.getElementById('stat-good').innerText = stats.good;
    document.getElementById('stat-miss').innerText = stats.miss;
    document.getElementById('stat-maxcombo').innerText = maxCombo;
}

// --- GAME LOOP & LOGIC ---
function getGameTime() {
    if (isVideoMode) {
        return videoEl.currentTime; 
    } else {
        // Calculate track position based on elapsed time * playback rate
        return (audioCtx.currentTime - startTime) * speedMultiplier;
    }
}

function takeDamage() {
    // EZ Mod reduces damage
    const dmg = activeMods.EZ ? CONFIG.damageMiss * 0.5 : (activeMods.HR ? CONFIG.damageMiss * 1.5 : CONFIG.damageMiss);
    health -= dmg;
    
    if (health <= 0) {
        health = 0;
        updateHUD();
        // NF Mod prevents failure
        if (!activeMods.NF) {
            endGame(false);
        }
    }
}

function heal() {
    const amount = activeMods.EZ ? CONFIG.healHit * 1.5 : CONFIG.healHit;
    health = Math.min(health + amount, 100);
}

function checkHit(lane) {
    const songTime = getGameTime() - (CONFIG.inputOffset / 1000);
    
    // Mods affect hit windows
    let hitWindow = 0.25;
    let perfectWindow = 0.08;
    
    if (activeMods.EZ) {
        hitWindow *= 1.4;
        perfectWindow *= 1.4;
    } else if (activeMods.HR) {
        hitWindow *= 0.7;
        perfectWindow *= 0.7;
    }

    let bestNote = null;
    let minDiff = Infinity;
    
    for (let note of notes) {
        if (note.lane === lane && !note.hit && !note.missed) {
            const diff = note.time - songTime;
            if (Math.abs(diff) < hitWindow && Math.abs(diff) < minDiff) {
                minDiff = Math.abs(diff);
                bestNote = note;
            }
        }
    }
    
    if (bestNote) {
        bestNote.hit = true;
        let points = 0;
        let text = "";
        let color = "#fff";
        
        if (minDiff <= perfectWindow) {

    points = 300;
    text = "PERFECT";
    color = "#00FF80";
    stats.perfect++;
    createParticles(lane, 15, color);
    audioManager.playSfx('PERFECT');
    heal();

} else {

    if (activeMods.PF) {
        // GOOD กลายเป็น MISS
        bestNote.missed = true;
        bestNote.hit = false;

        text = "MISS";
        color = "#FF3B3B";
        stats.miss++;

        // Record max combo before resetting to avoid updating every frame
        maxCombo = Math.max(maxCombo, combo);
        combo = 0;
        takeDamage(); // ถ้าคุณมีระบบลด HP

        audioManager.playSfx('MISS');

        if (SETTINGS.fx) {
            popups.push({
                text: text,
                x: getLaneX(lane),
                y: (canvas.logicalHeight || (canvas.height / (window.devicePixelRatio || 1))) * 0.65,
                life: 0.8,
                color: color,
                scale: 1.2
            });
        }

        updateHUD();
        return; // หยุดเลย ไม่ให้ได้คะแนน
    }

    // GOOD ปกติ
    points = 100;
    text = "GOOD";
    color = "#00E5FF";
    stats.good++;
    createParticles(lane, 8, color);
    audioManager.playSfx('GOOD');
    heal();
}

        if (bestNote.type === 'HOLD') {
            bestNote.holding = true;
            text = "HOLD"; 
        } else {
            combo++;
        }
        
        score += points * Math.min(Math.max(combo, 1), 10);
        
        if (SETTINGS.fx) {
            popups.push({
                text: text,
                x: getLaneX(lane),
                y: (canvas.logicalHeight || (canvas.height / (window.devicePixelRatio || 1))) * 0.65,
                life: 0.8,
                color: color,
                scale: 1.2
            });
        }
        
        updateHUD();
        if (conn && conn.open) {
            sendPeerMessage({ type: 'hit', id: (peer && peer.id) || null, lane, result: text, combo: combo, score: score });
        }
    }
}

function updateHUD() {
    document.getElementById('score-display').innerText = score.toLocaleString();
    document.getElementById('combo-display').innerText = combo;
    
    const hpBar = document.getElementById('health-bar');
    hpBar.style.width = `${health}%`;
    
    if (health < 30) hpBar.classList.add('danger');
    else hpBar.classList.remove('danger');
}

// --- RENDERING ---
function getLaneX(lane) {
    // use logical (CSS) width for lane math
    const laneWidth = (canvas.logicalWidth || canvas.width) / CONFIG.lanes;
    // no extra offset needed because canvas is visually centered via style.left
    const offsetX = 0;
    return offsetX + lane * laneWidth + laneWidth / 2;
}

function drawNote(ctx, x, y, radius, color, glowColor, isHollow = false, alpha = 1.0) {
    if (alpha <= 0) return;
    
    ctx.save();
    radius = Math.abs(radius); // Corrected this line to use 'radius' instead of 'size'
    ctx.globalAlpha = alpha;
    ctx.shadowBlur = 15;
    ctx.shadowColor = glowColor;
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.lineWidth = 4;
    
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    
    if (isHollow) {
        ctx.stroke();
    } else {
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, radius * 0.4, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.restore();
}

function drawHoldBody(ctx, x, yHead, yTail, width, color, alpha = 1.0) {
    const height = yHead - yTail;
    if (height <= 0 || alpha <= 0) return;
    
    ctx.save();
    ctx.globalAlpha = 0.6 * alpha;
    ctx.fillStyle = color;
    ctx.shadowBlur = 10;
    ctx.shadowColor = color;
    
    const grad = ctx.createLinearGradient(0, yTail, 0, yHead);
    grad.addColorStop(0, 'rgba(255,255,255,0.1)');
    grad.addColorStop(1, color);
    ctx.fillStyle = grad;
    
    ctx.fillRect(x - width/2, yTail, width, height);
    
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = 0.8 * alpha;
    ctx.fillRect(x - 2, yTail, 4, height);
    
    ctx.restore();
}

function createParticles(lane, count, color) {
    if (!SETTINGS.fx) return;
    const x = getLaneX(lane);
    const y = (canvas.logicalHeight || (canvas.height / (window.devicePixelRatio || 1))) - 120;
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 20,
            vy: (Math.random() - 0.5) * 20 - 10,
            life: 1.0,
            color: color,
            size: Math.random() * 5 + 2
        });
    }
}

function gameLoop() {
    const now = performance.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // use logical (CSS) canvas size for layout
    const laneWidth = (canvas.logicalWidth || canvas.width) / CONFIG.lanes;
    const targetY = (canvas.logicalHeight || (canvas.height / (window.devicePixelRatio || 1))) - 120;
    
    if (gameState === 'PLAYING' && !isPaused) {
        const songTime = getGameTime();
        // base speed for current difficulty
        const baseSpeed = DIFFICULTY_PRESETS[currentDifficulty].speed;

        // Adaptive Unfixed Speed Mod: only recalc every 200ms to save CPU
        let effectiveSpeed = baseSpeed;
        if (activeMods.UNF) {
            const nowMs = performance.now();
            if (nowMs - lastSpeedCalc > 200) {
                lastSpeedCalc = nowMs;

                // gather upcoming notes (next up to 12 notes) that are not missed
                const upcoming = notes.filter(n => !n.missed && n.time > songTime).slice(0, 12);
                if (upcoming.length >= 2) {
                    let diffs = [];
                    for (let i = 1; i < upcoming.length; i++) diffs.push(Math.max(0.001, upcoming[i].time - upcoming[i-1].time));
                    const avgIOI = diffs.reduce((a,b) => a+b, 0) / diffs.length; // seconds between notes

                    // reference IOI roughly mapped to baseSpeed (0.5s -> baseSpeed)
                    const refIOI = 0.5;
                    let estSpeed = baseSpeed * (refIOI / avgIOI);

                    // clamp to difficulty min/max to preserve intended challenge
                    const preset = DIFFICULTY_PRESETS[currentDifficulty];
                    const minS = preset.minSpeed || (baseSpeed * 0.6);
                    const maxS = preset.maxSpeed || (baseSpeed * 1.6);
                    estSpeed = Math.max(minS, Math.min(maxS, estSpeed));
                    cachedAdaptiveSpeed = estSpeed;
                }
            }
            effectiveSpeed = cachedAdaptiveSpeed;
        }

        const noteSpeedPx = effectiveSpeed * 80;
        
        // Draw Lanes
        for (let i = 0; i < CONFIG.lanes; i++) {
            const x = getLaneX(i);
            
            // Arrow Background / Lane Guides Toggle
            if (SETTINGS.laneBg) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(i * laneWidth, 0);
                ctx.lineTo(i * laneWidth, canvas.logicalHeight || (canvas.height / (window.devicePixelRatio || 1)));
                ctx.stroke();
            }
            
            // Lane Flash (Kept as feedback, but maybe disable if FX is off? Usually lane flash is essential)
            // We'll keep it unless strict FX rules apply.
            if (laneEffects[i] > 0.01 || laneHeld[i]) {
                const alpha = Math.max(laneEffects[i], laneHeld[i] ? 0.3 : 0);
                const grad = ctx.createLinearGradient(0, targetY, 0, 0);
                grad.addColorStop(0, LANE_GLOWS[i].replace('0.6', alpha * 0.6));
                grad.addColorStop(1, 'transparent');
                
                ctx.fillStyle = grad;
                ctx.fillRect(i * laneWidth, 0, laneWidth, canvas.height);
                
                if (laneEffects[i] > 0) laneEffects[i] -= dt * 5;
            }
            
            // Receptor
            const scale = 1.0 + (laneEffects[i] * 0.2) + (laneHeld[i] ? 0.1 : 0);
            drawNote(ctx, x, targetY, 35 * scale, LANE_COLORS[i], LANE_GLOWS[i], true);
        }
        
        // Draw Notes
        // 1. Hold Bodies
        for (let note of notes) {
            if (note.missed || note.processed || note.type !== 'HOLD') continue;
            
            const timeDiff = note.time - songTime;
            const yHead = targetY - (timeDiff * noteSpeedPx);
            const tailTime = note.time + note.duration;
            const tailDiff = tailTime - songTime;
            const yTail = targetY - (tailDiff * noteSpeedPx);
            
            // Hidden Mod Opacity Logic
            let alpha = 1.0;
            if (activeMods.HD) {
                alpha = Math.min(Math.max(timeDiff - 0.2, 0) * 2, 1);
            }

            if (yTail < (canvas.logicalHeight || canvas.height / dpr) && yHead > -50) {
                drawHoldBody(ctx, getLaneX(note.lane), yHead, yTail, 40, LANE_COLORS[note.lane], alpha);
            }
            
            // Hold Logic
            if (note.hit && !note.processed) {
                if (laneHeld[note.lane]) {
                    score += 1; 
                    createParticles(note.lane, 1, LANE_COLORS[note.lane]);
                    if (songTime >= tailTime) {
                        note.processed = true;
                        score += CONFIG.holdCompletePoints;
                        combo++;
                        if (SETTINGS.fx) {
                            popups.push({ text: "COMPLETE", x: getLaneX(note.lane), y: targetY, life: 0.5, color: "#fff", scale: 1 });
                        }
                        audioManager.playSfx('PERFECT');
                        updateHUD();
                    }
                } else {
                    if (songTime < tailTime - 0.1) {
                        note.processed = true;
                        note.missed = true;
                        // record max combo at the moment of miss/drop
                        maxCombo = Math.max(maxCombo, combo);
                        combo = 0;
                        stats.miss++;
                        takeDamage(); 
                        if (SETTINGS.fx) {
                            popups.push({ text: "DROP", x: getLaneX(note.lane), y: targetY, life: 0.5, color: "#ff4444", scale: 1 });
                        }
                        audioManager.playSfx('MISS');
                        updateHUD();
                    }
                }
            }
        }
        
        // 2. Note Heads
        for (let note of notes) {
            if (note.hit && note.type === 'TAP') continue;
            if (note.processed || note.missed) continue;
            
            const timeDiff = note.time - songTime;
            const y = targetY - (timeDiff * noteSpeedPx);
            
            // Miss Logic
            if (timeDiff < -0.2 && !note.hit && !note.missed) {
                note.missed = true;
                stats.miss++;
                // record max combo before resetting
                maxCombo = Math.max(maxCombo, combo);
                combo = 0;
                takeDamage();
                if (SETTINGS.fx) {
                    popups.push({ text: "MISS", x: getLaneX(note.lane), y: targetY, life: 0.5, color: "#ff4444", scale: 1 });
                }
                audioManager.playSfx('MISS');
                updateHUD();
            }
            
            let renderY = y;
            if (note.type === 'HOLD' && note.hit) renderY = targetY;
            
            // Hidden Mod Opacity Logic for Heads
            let alpha = 1.0;
            if (activeMods.HD) {
                alpha = Math.min(Math.max(timeDiff - 0.2, 0) * 2, 1);
            }

            if (renderY > -50 && renderY < (canvas.logicalHeight || canvas.height / dpr) + 50) {
                drawNote(ctx, getLaneX(note.lane), renderY, 30, LANE_COLORS[note.lane], LANE_GLOWS[note.lane], false, alpha);
            }
        }
        
        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= dt * 3;
            p.vy += 0.5; 
            
            if (p.life <= 0) {
                particles.splice(i, 1);
            } else {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        ctx.globalAlpha = 1;
        
        // Popups
        for (let i = popups.length - 1; i >= 0; i--) {
            const p = popups[i];
            p.y -= dt * 80;
            p.life -= dt;
            
            if (p.life <= 0) {
                popups.splice(i, 1);
            } else {
                ctx.save();
                ctx.translate(p.x, p.y);
                const scale = p.scale * (0.8 + p.life * 0.2);
                ctx.scale(scale, scale);
                ctx.fillStyle = p.color;
                ctx.font = "bold 32px 'Rajdhani'";
                ctx.textAlign = "center";
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 10;
                ctx.fillText(p.text, 0, 0);
                ctx.restore();
            }
        }
        
        // Progress Bar
        if (trackDuration > 0) {
            const pct = (songTime / trackDuration) * 100;
            document.getElementById('progress-bar').style.width = `${Math.min(pct, 100)}%`;
        }
        
    } else if (gameState === 'MENU' || isPaused) {
        // Menu visualizer
        const time = now / 1000;
        for (let i = 0; i < CONFIG.lanes; i++) {
            const x = getLaneX(i);
            const y = (canvas.logicalHeight || (canvas.height / (window.devicePixelRatio || 1))) - 120 + Math.sin(time * 3 + i) * 15;
            ctx.globalAlpha = 0.2;
            drawNote(ctx, x, y, 35, LANE_COLORS[i], LANE_GLOWS[i], true);
        }
        ctx.globalAlpha = 1;
    }
    
    animationFrameId = requestAnimationFrame(gameLoop);
}

// Start
document.addEventListener('DOMContentLoaded', initGame);


</script>

</body></html>
